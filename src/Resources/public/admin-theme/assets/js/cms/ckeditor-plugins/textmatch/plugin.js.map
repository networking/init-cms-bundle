{"version":3,"file":"plugin.js","names":["findElementAtOffset","elements","offset","max","length","currentOffset","i","current","getText","element","CKEDITOR","plugins","add","textMatch","match","range","callback","textAndOffset","getTextAndOffset","fillingCharSequence","dom","selection","FILLING_CHAR_SEQUENCE","fillingSequenceOffset","text","indexOf","replace","result","getRangeInText","start","end","slice","collapsed","elementIndex","textNodes","getAdjacentTextNodes","nodeReached","startContainerIsText","startContainer","type","NODE_ELEMENT","arr","checker","equals","startOffset","getIndex","currentNode","resultRange","root","startData","endData","setStart","setEnd","Error","siblings","node","collection","getParent","getChildren","getItem","NODE_TEXT","unshift","push"],"sources":["textmatch/plugin.js"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n'use strict';\n\n( function() {\n\n\tCKEDITOR.plugins.add( 'textmatch', {} );\n\n\t/**\n\t * A global namespace for methods exposed by the [Text Match](https://ckeditor.com/cke4/addon/textmatch) plugin.\n\t *\n\t * The most important function is {@link #match} which performs a text\n\t * search in the DOM.\n\t *\n\t * @singleton\n\t * @class\n\t * @since 4.10.0\n\t */\n\tCKEDITOR.plugins.textMatch = {};\n\n\t/**\n\t * Allows to search in the DOM for matching text using a callback which operates on strings instead of text nodes.\n\t * Returns {@link CKEDITOR.dom.range} and the matching text.\n\t *\n\t * ```javascript\n\t *\tvar range = editor.getSelection().getRanges()[ 0 ];\n\t *\n\t *\tCKEDITOR.plugins.textMatch.match( range, function( text, offset ) {\n\t *\t\t// Let's assume that text is 'Special thanks to #jo.' and offset is 21.\n\t *\t\t// The offset \"21\" means that the caret is between '#jo' and '.'.\n\t *\n\t *\t\t// Get the text before the caret.\n\t *\t\tvar left = text.slice( 0, offset ),\n\t *\t\t\t// Will look for a literal '#' character and at least two word characters.\n\t *\t\t\tmatch = left.match( /#\\w{2,}$/ );\n\t *\n\t *\t\tif ( !match ) {\n\t *\t\t\treturn null;\n\t *\t\t}\n\t *\n\t *\t\t// The matching fragment is the '#jo', which can\n\t *\t\t// be identified by the following offsets: { start: 18, end: 21 }.\n\t *\t\treturn { start: match.index, end: offset };\n\t *\t} );\n\t * ```\n\t *\n\t * @member CKEDITOR.plugins.textMatch\n\t * @param {CKEDITOR.dom.range} range A collapsed range &mdash; the position from which the scanning starts.\n\t * Usually the caret position.\n\t * @param {Function} testCallback A callback executed to check if the text matches.\n\t * @param {String} testCallback.text The full text to check.\n\t * @param {Number} testCallback.rangeOffset An offset of the `range` in the `text` to be checked.\n\t * @param {Object} [testCallback.return] The position of the matching fragment (`null` if nothing matches).\n\t * @param {Number} testCallback.return.start The offset of the start of the matching fragment.\n\t * @param {Number} testCallback.return.end The offset of the end of the matching fragment.\n\t *\n\t * @returns {Object/null} An object with information about the matching text or `null`.\n\t * @returns {String} return.text The matching text.\n\t * The text does not reflect the range offsets. The range could contain additional,\n\t * browser-related characters like {@link CKEDITOR.dom.selection#FILLING_CHAR_SEQUENCE}.\n\t * @returns {CKEDITOR.dom.range} return.range A range in the DOM for the text that matches.\n\t */\n\tCKEDITOR.plugins.textMatch.match = function( range, callback ) {\n\t\tvar textAndOffset = CKEDITOR.plugins.textMatch.getTextAndOffset( range ),\n\t\t\tfillingCharSequence = CKEDITOR.dom.selection.FILLING_CHAR_SEQUENCE,\n\t\t\tfillingSequenceOffset = 0;\n\n\t\tif ( !textAndOffset ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remove filling char sequence for clean query (#2038).\n\t\tif ( textAndOffset.text.indexOf( fillingCharSequence ) == 0 ) {\n\t\t\tfillingSequenceOffset = fillingCharSequence.length;\n\n\t\t\ttextAndOffset.text = textAndOffset.text.replace( fillingCharSequence, '' );\n\t\t\ttextAndOffset.offset -= fillingSequenceOffset;\n\t\t}\n\n\t\tvar result = callback( textAndOffset.text, textAndOffset.offset );\n\n\t\tif ( !result ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn {\n\t\t\trange: CKEDITOR.plugins.textMatch.getRangeInText( range, result.start, result.end + fillingSequenceOffset ),\n\t\t\ttext: textAndOffset.text.slice( result.start, result.end )\n\t\t};\n\t};\n\n\t/**\n\t * Returns a text (as a string) in which the DOM range is located (the function scans for adjacent text nodes)\n\t * and the offset of the caret in that text.\n\t *\n\t * ## Examples\n\t *\n\t * * `{}` is the range position in the text node (it means that the text node is **not** split at that position).\n\t * * `[]` is the range position in the element (it means that the text node is split at that position).\n\t * * `.` is a separator for text nodes (it means that the text node is split at that position).\n\t *\n\t * Examples:\n\t *\n\t * ```\n\t *\tInput: <p>he[]llo</p>\n\t *\tResult: { text: 'hello', offset: 2 }\n\t *\n\t *\tInput: <p>he.llo{}</p>\n\t *\tResult: { text: 'hello', offset: 5 }\n\t *\n\t *\tInput: <p>{}he.ll<i>o</i></p>\n\t *\tResult: { text: 'hell', offset: 0 }\n\t *\n\t *\tInput: <p>he{}<i>ll</i>o</p>\n\t *\tResult: { text: 'he', offset: 2 }\n\t *\n\t *\tInput: <p>he<i>ll</i>o.m{}y.friend</p>\n\t *\tResult: { text: 'omyfriend', offset: 2 }\n\t * ```\n\t *\n\t * @member CKEDITOR.plugins.textMatch\n\t * @param {CKEDITOR.dom.range} range\n\t * @returns {Object/null}\n\t * @returns {String} return.text The text in which the DOM range is located.\n\t * @returns {Number} return.offset An offset of the caret.\n\t */\n\tCKEDITOR.plugins.textMatch.getTextAndOffset = function( range ) {\n\t\tif ( !range.collapsed ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar text = '', offset = 0,\n\t\t\ttextNodes = CKEDITOR.plugins.textMatch.getAdjacentTextNodes( range ),\n\t\t\tnodeReached = false,\n\t\t\telementIndex,\n\t\t\tstartContainerIsText = ( range.startContainer.type != CKEDITOR.NODE_ELEMENT );\n\n\t\tif ( startContainerIsText ) {\n\t\t\t// Determining element index in textNodes array.\n\t\t\telementIndex = indexOf( textNodes, function( current ) {\n\t\t\t\treturn range.startContainer.equals( current );\n\t\t\t} );\n\t\t} else {\n\t\t\t// Based on range startOffset decreased by first text node index.\n\t\t\telementIndex = range.startOffset - ( textNodes[ 0 ] ? textNodes[ 0 ].getIndex() : 0 );\n\t\t}\n\n\t\tvar max = textNodes.length;\n\t\tfor ( var i = 0; i < max; i += 1 ) {\n\t\t\tvar currentNode = textNodes[ i ];\n\t\t\ttext += currentNode.getText();\n\n\t\t\t// We want to increase text offset only when startContainer is not reached.\n\t\t\tif ( !nodeReached ) {\n\t\t\t\tif ( startContainerIsText ) {\n\t\t\t\t\tif ( i == elementIndex ) {\n\t\t\t\t\t\tnodeReached = true;\n\t\t\t\t\t\toffset += range.startOffset;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toffset += currentNode.getText().length;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ( i == elementIndex ) {\n\t\t\t\t\t\tnodeReached = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t// In below example there are three text nodes in p element and four possible offsets ( 0, 1, 2, 3 )\n\t\t\t\t\t// We are going to increase offset while iteration:\n\t\t\t\t\t// index 0 ==> 0\n\t\t\t\t\t// index 1 ==> 3\n\t\t\t\t\t// index 2 ==> 3 + 3\n\t\t\t\t\t// index 3 ==> 3 + 3 + 2\n\n\t\t\t\t\t// <p> foo bar ba </p>\n\t\t\t\t\t//    0^^^1^^^2^^3\n\t\t\t\t\tif ( i > 0 ) {\n\t\t\t\t\t\toffset += textNodes[ i - 1 ].getText().length;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If element index at last element we also want to increase offset.\n\t\t\t\t\tif ( max == elementIndex && i + 1 == max ) {\n\t\t\t\t\t\toffset += currentNode.getText().length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\ttext: text,\n\t\t\toffset: offset\n\t\t};\n\t};\n\n\t/**\n\t * Transforms the `start` and `end` offsets in the text generated by the {@link #getTextAndOffset}\n\t * method into a DOM range.\n\t *\n\t * ## Examples\n\t *\n\t * * `{}` is the range position in the text node (it means that the text node is **not** split at that position).\n\t * * `.` is a separator for text nodes (it means that the text node is split at that position).\n\t *\n\t * Examples:\n\t *\n\t * ```\n\t *\tInput: <p>f{}oo.bar</p>, 0, 3\n\t *\tResult: <p>{foo}.bar</p>\n\t *\n\t *\tInput: <p>f{}oo.bar</p>, 1, 5\n\t *\tResult: <p>f{oo.ba}r</p>\n\t * ```\n\t *\n\t * @member CKEDITOR.plugins.textMatch\n\t * @param {CKEDITOR.dom.range} range\n\t * @param {Number} start A start offset.\n\t * @param {Number} end An end offset.\n\t * @returns {CKEDITOR.dom.range} Transformed range.\n\t */\n\tCKEDITOR.plugins.textMatch.getRangeInText = function( range, start, end ) {\n\t\tvar resultRange = new CKEDITOR.dom.range( range.root ),\n\t\t\telements = CKEDITOR.plugins.textMatch.getAdjacentTextNodes( range ),\n\t\t\tstartData = findElementAtOffset( elements, start ),\n\t\t\tendData = findElementAtOffset( elements, end );\n\n\t\tresultRange.setStart( startData.element, startData.offset );\n\t\tresultRange.setEnd( endData.element, endData.offset );\n\n\t\treturn resultRange;\n\t};\n\n\t/**\n\t * Creates a collection of adjacent text nodes which are between DOM elements, starting from the given range.\n\t * This function works only for collapsed ranges.\n\t *\n\t * ## Examples\n\t *\n\t * * `{}` is the range position in the text node (it means that the text node is **not** split at that position).\n\t * * `.` is a separator for text nodes (it means that the text node is split at that position).\n\t *\n\t * Examples:\n\t *\n\t * ```\n\t *\tInput: <p>he.llo{}</p>\n\t *\tResult: [ 'he', 'llo' ]\n\t *\n\t *\tInput: <p>{}he.ll<i>o</i></p>\n\t *\tResult:  [ 'he', 'll' ]\n\t *\n\t *\tInput: <p>he{}<i>ll</i>o.</p>\n\t *\tResult:  [ 'he' ]\n\t *\n\t *\tInput: <p>he<i>ll</i>{}o.my.friend</p>\n\t *\tResult: [ 'o', 'my', 'friend' ]\n\t * ```\n\t *\n\t * @member CKEDITOR.plugins.textMatch\n\t * @param {CKEDITOR.dom.range} range\n\t * @return {CKEDITOR.dom.text[]} An array of text nodes.\n\t */\n\tCKEDITOR.plugins.textMatch.getAdjacentTextNodes = function( range ) {\n\t\tif ( !range.collapsed ) {\n\t\t\tthrow new Error( 'Range must be collapsed.' ); // %REMOVE_LINE%\n\t\t\t// Reachable in prod mode.\n\t\t\treturn []; // jshint ignore:line\n\t\t}\n\n\t\tvar collection = [],\n\t\t\tsiblings,\n\t\t\telementIndex,\n\t\t\tnode, i;\n\n\t\tif ( range.startContainer.type != CKEDITOR.NODE_ELEMENT ) {\n\t\t\tsiblings = range.startContainer.getParent().getChildren();\n\t\t\telementIndex = range.startContainer.getIndex();\n\t\t} else {\n\t\t\tsiblings = range.startContainer.getChildren();\n\t\t\telementIndex = range.startOffset;\n\t\t}\n\n\t\ti = elementIndex;\n\t\twhile ( node = siblings.getItem( --i ) ) {\n\t\t\tif ( node.type == CKEDITOR.NODE_TEXT ) {\n\t\t\t\tcollection.unshift( node );\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ti = elementIndex;\n\t\twhile ( node = siblings.getItem( i++ ) ) {\n\t\t\tif ( node.type == CKEDITOR.NODE_TEXT ) {\n\t\t\t\tcollection.push( node );\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn collection;\n\t};\n\n\tfunction findElementAtOffset( elements, offset ) {\n\t\tvar max = elements.length,\n\t\t\tcurrentOffset = 0;\n\t\tfor ( var i = 0; i < max; i += 1 ) {\n\t\t\tvar current = elements[ i ];\n\t\t\tif ( offset >= currentOffset && currentOffset + current.getText().length >= offset ) {\n\t\t\t\treturn {\n\t\t\t\t\telement: current,\n\t\t\t\t\toffset: offset - currentOffset\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tcurrentOffset += current.getText().length;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tfunction indexOf( arr, checker ) {\n\t\tfor ( var i = 0; i < arr.length; i++ ) {\n\t\t\tif ( checker( arr[ i ] ) ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n} )();\n"]}