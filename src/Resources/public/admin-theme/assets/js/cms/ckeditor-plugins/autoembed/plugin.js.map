{"version":3,"file":"plugin.js","names":["validLinkRegExp","CKEDITOR","plugins","add","requires","lang","init","editor","embedCandidatePasted","currentId","on","evt","data","dataTransfer","getTransferType","DATA_TRANSFER_INTERNAL","match","dataValue","decodeURI","substr","id","notification","anchor","editable","findOne","autoembed","href","widgetDef","autoEmbed","getWidgetDefinition","warn","instance","defaults","element","dom","createFromHtml","template","output","wrapper","widgets","wrapElement","name","temp","documentFragment","getDocument","append","initOn","finalizeCreation","showNotification","embeddingInProgress","loadContent","noNotifications","callback","selection","getSelection","insertRange","createRange","fire","dontUpdate","bookmark","createBookmarks","startNode","endNode","env","ie","version","equals","getNext","setStartBefore","setEndAfter","insertElement","contains","selectBookmarks","remove","hide","errorCallback","destroy","embeddingFailed","autoEmbedLink","url","opt","config","autoEmbed_widget","registered","split","shift"],"sources":["autoembed/plugin.js"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n'use strict';\n\n( function() {\n\tvar validLinkRegExp = /^<a[^>]+href=\"([^\"]+)\"[^>]*>([^<]+)<\\/a>$/i;\n\n\tCKEDITOR.plugins.add( 'autoembed', {\n\t\trequires: 'autolink,undo',\n\t\tlang: 'ar,az,bg,ca,cs,da,de,de-ch,el,en,en-au,eo,es,es-mx,et,eu,fa,fr,gl,hr,hu,id,it,ja,km,ko,ku,lt,lv,mk,nb,nl,oc,pl,pt,pt-br,ro,ru,sk,sq,sr,sr-latn,sv,tr,ug,uk,vi,zh,zh-cn', // %REMOVE_LINE_CORE%\n\t\tinit: function( editor ) {\n\t\t\tvar currentId = 1,\n\t\t\t\tembedCandidatePasted;\n\n\t\t\teditor.on( 'paste', function( evt ) {\n\t\t\t\tif ( evt.data.dataTransfer.getTransferType( editor ) == CKEDITOR.DATA_TRANSFER_INTERNAL ) {\n\t\t\t\t\tembedCandidatePasted = 0;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar match = evt.data.dataValue.match( validLinkRegExp );\n\n\t\t\t\tembedCandidatePasted = match != null && decodeURI( match[ 1 ] ) == decodeURI( match[ 2 ] );\n\n\t\t\t\t// Expecting exactly one <a> tag spanning the whole pasted content.\n\t\t\t\t// The tag has to have same href as content.\n\t\t\t\tif ( embedCandidatePasted ) {\n\t\t\t\t\tevt.data.dataValue = '<a data-cke-autoembed=\"' + ( ++currentId ) + '\"' + evt.data.dataValue.substr( 2 );\n\t\t\t\t}\n\t\t\t}, null, null, 20 ); // Execute after autolink.\n\n\t\t\teditor.on( 'afterPaste', function() {\n\t\t\t\t// If one pasted an embeddable link and then undone the action, the link in the content holds the\n\t\t\t\t// data-cke-autoembed attribute and may be embedded on *any* successive paste.\n\t\t\t\t// This check ensures that autoEmbedLink is called only if afterPaste is fired *right after*\n\t\t\t\t// embeddable link got into the content. (https://dev.ckeditor.com/ticket/13532)\n\t\t\t\tif ( embedCandidatePasted ) {\n\t\t\t\t\tautoEmbedLink( editor, currentId );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t} );\n\n\tfunction autoEmbedLink( editor, id ) {\n\t\tvar anchor = editor.editable().findOne( 'a[data-cke-autoembed=\"' + id + '\"]' ),\n\t\t\tlang = editor.lang.autoembed,\n\t\t\tnotification;\n\n\t\tif ( !anchor || !anchor.data( 'cke-saved-href' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar href = anchor.data( 'cke-saved-href' ),\n\t\t\twidgetDef = CKEDITOR.plugins.autoEmbed.getWidgetDefinition( editor, href );\n\n\t\tif ( !widgetDef ) {\n\t\t\tCKEDITOR.warn( 'autoembed-no-widget-def' );\n\t\t\treturn;\n\t\t}\n\n\t\t\t// TODO Move this to a method in the widget plugin. https://dev.ckeditor.com/ticket/13408\n\t\tvar defaults = typeof widgetDef.defaults == 'function' ? widgetDef.defaults() : widgetDef.defaults,\n\t\t\telement = CKEDITOR.dom.element.createFromHtml( widgetDef.template.output( defaults ) ),\n\t\t\tinstance,\n\t\t\twrapper = editor.widgets.wrapElement( element, widgetDef.name ),\n\t\t\ttemp = new CKEDITOR.dom.documentFragment( wrapper.getDocument() );\n\n\t\ttemp.append( wrapper );\n\t\tinstance = editor.widgets.initOn( element, widgetDef );\n\n\t\tif ( !instance ) {\n\t\t\tfinalizeCreation();\n\t\t\treturn;\n\t\t}\n\n\t\tnotification = editor.showNotification( lang.embeddingInProgress, 'info' );\n\t\tinstance.loadContent( href, {\n\t\t\tnoNotifications: true,\n\t\t\tcallback: function() {\n\t\t\t\t// DOM might be invalidated in the meantime, so find the anchor again.\n\t\t\t\tvar anchor = editor.editable().findOne( 'a[data-cke-autoembed=\"' + id + '\"]' );\n\n\t\t\t\t// Anchor might be removed in the meantime.\n\t\t\t\tif ( anchor ) {\n\t\t\t\t\tvar selection = editor.getSelection(),\n\t\t\t\t\t\tinsertRange = editor.createRange(),\n\t\t\t\t\t\teditable = editor.editable();\n\n\t\t\t\t\t// Save the changes in editor contents that happened *after* the link was pasted\n\t\t\t\t\t// but before it gets embedded (i.e. user pasted and typed).\n\t\t\t\t\teditor.fire( 'saveSnapshot' );\n\n\t\t\t\t\t// Lock snapshot so we don't make unnecessary undo steps in\n\t\t\t\t\t// editable.insertElement() below, which would include bookmarks. (https://dev.ckeditor.com/ticket/13429)\n\t\t\t\t\teditor.fire( 'lockSnapshot', { dontUpdate: true } );\n\n\t\t\t\t\t// Bookmark current selection. (https://dev.ckeditor.com/ticket/13429)\n\t\t\t\t\tvar bookmark = selection.createBookmarks( false )[ 0 ],\n\t\t\t\t\t\tstartNode = bookmark.startNode,\n\t\t\t\t\t\tendNode = bookmark.endNode || startNode;\n\n\t\t\t\t\t// When url is pasted, IE8 sets the caret after <a> element instead of inside it.\n\t\t\t\t\t// So, if user hasn't changed selection, bookmark is inserted right after <a>.\n\t\t\t\t\t// Then, after pasting embedded content, bookmark is still in DOM but it is\n\t\t\t\t\t// inside the original element. After selection recreation it would end up before widget:\n\t\t\t\t\t// <p>A <a /><bm /></p><p>B</p>  -->  <p>A <bm /></p><widget /><p>B</p>  -->  <p>A ^</p><widget /><p>B</p>\n\t\t\t\t\t// We have to fix this IE8 behavior so it is the same as on other browsers.\n\t\t\t\t\tif ( CKEDITOR.env.ie && CKEDITOR.env.version < 9 && !bookmark.endNode && startNode.equals( anchor.getNext() ) ) {\n\t\t\t\t\t\tanchor.append( startNode );\n\t\t\t\t\t}\n\n\t\t\t\t\tinsertRange.setStartBefore( anchor );\n\t\t\t\t\tinsertRange.setEndAfter( anchor );\n\n\t\t\t\t\teditable.insertElement( wrapper, insertRange );\n\n\t\t\t\t\t// If both bookmarks are still in DOM, it means that selection was not inside\n\t\t\t\t\t// an anchor that got substituted. We can safely recreate that selection. (https://dev.ckeditor.com/ticket/13429)\n\t\t\t\t\tif ( editable.contains( startNode ) && editable.contains( endNode ) ) {\n\t\t\t\t\t\tselection.selectBookmarks( [ bookmark ] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If one of bookmarks is not in DOM, clean up leftovers.\n\t\t\t\t\t\tstartNode.remove();\n\t\t\t\t\t\tendNode.remove();\n\t\t\t\t\t}\n\n\t\t\t\t\teditor.fire( 'unlockSnapshot' );\n\t\t\t\t}\n\n\t\t\t\tnotification.hide();\n\t\t\t\tfinalizeCreation();\n\t\t\t},\n\n\t\t\terrorCallback: function() {\n\t\t\t\tnotification.hide();\n\t\t\t\teditor.widgets.destroy( instance, true );\n\t\t\t\teditor.showNotification( lang.embeddingFailed, 'info' );\n\t\t\t}\n\t\t} );\n\n\t\tfunction finalizeCreation() {\n\t\t\teditor.widgets.finalizeCreation( temp );\n\t\t}\n\t}\n\n\tCKEDITOR.plugins.autoEmbed = {\n\t\t/**\n\t\t * Gets the definition of the widget that should be used to automatically embed the specified link.\n\t\t *\n\t\t * This method uses the value of the {@link CKEDITOR.config#autoEmbed_widget} option.\n\t\t *\n\t\t * @since 4.5.0\n\t\t * @member CKEDITOR.plugins.autoEmbed\n\t\t * @param {CKEDITOR.editor} editor\n\t\t * @param {String} url The URL to be embedded.\n\t\t * @returns {CKEDITOR.plugins.widget.definition/null} The definition of the widget to be used to embed the link.\n\t\t */\n\t\tgetWidgetDefinition: function( editor, url ) {\n\t\t\tvar opt = editor.config.autoEmbed_widget || 'embed,embedSemantic',\n\t\t\t\tname,\n\t\t\t\twidgets = editor.widgets.registered;\n\n\t\t\tif ( typeof opt == 'string' ) {\n\t\t\t\topt = opt.split( ',' );\n\n\t\t\t\twhile ( ( name = opt.shift() ) ) {\n\t\t\t\t\tif ( widgets[ name ] ) {\n\t\t\t\t\t\treturn widgets[ name ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if ( typeof opt == 'function' ) {\n\t\t\t\treturn widgets[ opt( url ) ];\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t};\n\n\t/**\n\t * Specifies the widget to use to automatically embed a link. The default value\n\t * of this option defines that either the [Media Embed](https://ckeditor.com/cke4/addon/embed) or\n\t * [Semantic Media Embed](https://ckeditor.com/cke4/addon/embedsemantic) widgets will be used, depending on which is enabled.\n\t *\n\t * The general behavior:\n\t *\n\t * * If a string (widget names separated by commas) is provided, then the first of the listed widgets which is registered\n\t *   will be used. For example, if `'foo,bar,bom'` is set and widgets `'bar'` and `'bom'` are registered, then `'bar'`\n\t *   will be used.\n\t * * If a callback is specified, then it will be executed with the URL to be embedded and it should return the\n\t *   name of the widget to be used. It allows to use different embed widgets for different URLs.\n\t *\n\t * Example:\n\t *\n\t * ```js\n\t * // Defines that embedSemantic should be used (regardless of whether embed is defined).\n\t * config.autoEmbed_widget = 'embedSemantic';\n\t * ```\n\t *\n\t * Using with custom embed widgets:\n\t *\n\t * ```js\n\t * config.autoEmbed_widget = 'customEmbed';\n\t * ```\n\t *\n\t * **Note:** Plugin names are always lower case, while widget names are not, so widget names do not have to equal plugin names.\n\t * For example, there is the `embedsemantic` plugin and the `embedSemantic` widget.\n\t *\n\t * Read more in the {@glink features/media_embed#automatic-embedding-on-paste documentation}\n\t * and see the {@glink examples/mediaembed example}.\n\t *\n\t * @since 4.5.0\n\t * @cfg {String/Function} [autoEmbed_widget='embed,embedSemantic']\n\t * @member CKEDITOR.config\n\t */\n} )();\n"]}