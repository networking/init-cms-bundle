{"version":3,"file":"plugin.js","names":["Jsonp","_attachScript","url","errorCallback","script","CKEDITOR","dom","element","setAttribute","on","document","getBody","append","sendRequest","urlTemplate","urlParams","callback","request","scriptElement","callbackKey","tools","getNextNumber","cleanUp","remove","_","jsonpCallbacks","response","setTimeout","this","output","cancel","plugins","add","lang","requires","onLoad","init","dialog","path","embedBase","createWidgetBaseDefinition","editor","aggregator","embedbase","mask","template","pathName","_cache","urlRegExp","evt","_sendRequest","data","html","retHtml","_responseToHtml","errorMessage","loadContent","opts","that","cachedResponse","_getCachedResponse","noNotifications","finishLoading","msg","_handleError","task","_createTask","fire","widgets","instances","id","warn","done","_handleResponse","_cacheResponse","isUrlValid","test","getErrorMessage","messageTypeOrMessage","suffix","message","jsonpRequest","providerUrl","encodeURIComponent","evtData","_setContent","showNotification","type","htmlEncodeAttr","title","replace","content","setData","setHtml","isFinished","notificationAggregator","fetchingMany","fetchingOne","notification","hide","createTask","_jsonp"],"sources":["embedbase/plugin.js"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n( function() {\n\t'use strict';\n\n\t/**\n\t * JSONP communication.\n\t *\n\t * @private\n\t * @singleton\n\t * @class CKEDITOR.plugins.embedBase._jsonp\n\t */\n\tvar Jsonp = {\n\t\t/**\n\t\t * Creates a `<script>` element and attaches it to the document `<body>`.\n\t\t *\n\t\t * @private\n\t\t */\n\t\t_attachScript: function( url, errorCallback ) {\n\t\t\t// ATM we cannot use CKE scriptloader here, because it will make sure that script\n\t\t\t// with given URL is added only once.\n\t\t\tvar script = new CKEDITOR.dom.element( 'script' );\n\t\t\tscript.setAttribute( 'src', url );\n\t\t\tscript.on( 'error', errorCallback );\n\n\t\t\tCKEDITOR.document.getBody().append( script );\n\n\t\t\treturn script;\n\t\t},\n\n\t\t/**\n\t\t * Sends a request using the JSONP technique.\n\t\t *\n\t\t * @param {CKEDITOR.template} urlTemplate The template of the URL to be requested. All properties\n\t\t * passed in `urlParams` can be used, plus a `{callback}`, which represents a JSONP callback, must be defined.\n\t\t * @param {Object} urlParams Parameters to be passed to the `urlTemplate`.\n\t\t * @param {Function} callback\n\t\t * @param {Function} [errorCallback]\n\t\t * @returns {Object} The request object with a `cancel()` method.\n\t\t */\n\t\tsendRequest: function( urlTemplate, urlParams, callback, errorCallback ) {\n\t\t\tvar request = {};\n\t\t\turlParams = urlParams || {};\n\n\t\t\tvar callbackKey = CKEDITOR.tools.getNextNumber(),\n\t\t\t\tscriptElement;\n\n\t\t\turlParams.callback = 'CKEDITOR._.jsonpCallbacks[' + callbackKey + ']';\n\n\t\t\tCKEDITOR._.jsonpCallbacks[ callbackKey ] = function( response ) {\n\t\t\t\t// On IEs scripts are sometimes loaded synchronously. It is bad for two reasons:\n\t\t\t\t// * nature of sendRequest() is unstable,\n\t\t\t\t// * scriptElement does not exist yet.\n\t\t\t\tsetTimeout( function() {\n\t\t\t\t\tcleanUp();\n\t\t\t\t\tcallback( response );\n\t\t\t\t} );\n\t\t\t};\n\n\t\t\tscriptElement = this._attachScript( urlTemplate.output( urlParams ), function() {\n\t\t\t\tcleanUp();\n\t\t\t\terrorCallback && errorCallback();\n\t\t\t} );\n\n\t\t\trequest.cancel = cleanUp;\n\n\t\t\tfunction cleanUp() {\n\t\t\t\tif ( scriptElement ) {\n\t\t\t\t\tscriptElement.remove();\n\t\t\t\t\tdelete CKEDITOR._.jsonpCallbacks[ callbackKey ];\n\t\t\t\t\tscriptElement = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn request;\n\t\t}\n\t};\n\n\tCKEDITOR.plugins.add( 'embedbase', {\n\t\tlang: 'ar,az,bg,ca,cs,da,de,de-ch,en,en-au,eo,es,es-mx,et,eu,fa,fr,gl,hr,hu,id,it,ja,ko,ku,lv,nb,nl,oc,pl,pt,pt-br,ro,ru,sk,sq,sr,sr-latn,sv,tr,ug,uk,zh,zh-cn', // %REMOVE_LINE_CORE%\n\t\trequires: 'dialog,widget,notificationaggregator',\n\n\t\tonLoad: function() {\n\t\t\tCKEDITOR._.jsonpCallbacks = {};\n\t\t},\n\n\t\tinit: function() {\n\t\t\tCKEDITOR.dialog.add( 'embedBase', this.path + 'dialogs/embedbase.js' );\n\t\t}\n\t} );\n\n\t/**\n\t * Creates a new embed widget base definition. After other necessary properties are filled this definition\n\t * may be {@link CKEDITOR.plugins.widget.repository#add registered} as a new, independent widget for\n\t * embedding content.\n\t *\n\t * By default an embed widget is set up to work with [oEmbed providers](http://www.oembed.com/) using JSONP\n\t * requests, such as [Iframely](https://iframely.com/) or [Noembed](https://noembed.com/). It can be,\n\t * however, easily configured to use other providers and communication methods, including custom systems\n\t * or local embed databases.\n\t *\n\t * See example usage of this method in:\n\t *\n\t * * [/plugins/embed/plugin.js](https://github.com/ckeditor/ckeditor4/blob/master/plugins/embed/plugin.js)\n\t * * [/plugins/embedsemantic/plugin.js](https://github.com/ckeditor/ckeditor4/blob/master/plugins/embedsemantic/plugin.js)\n\t *\n\t * Note that both these plugins reuse the [dialog](https://github.com/ckeditor/ckeditor4/blob/master/plugins/embedbase/dialogs/embedbase.js)\n\t * defined by the `embedbase` plugin. Integration of the asynchronous way of loading content with a dialog requires additional\n\t * effort. Check the dialog's code for more details.\n\t *\n\t * @static\n\t * @param {CKEDITOR.editor} editor\n\t * @returns {CKEDITOR.plugins.embedBase.baseDefinition}\n\t * @member CKEDITOR.plugins.embedBase\n\t */\n\tfunction createWidgetBaseDefinition( editor ) {\n\t\tvar aggregator,\n\t\t\tlang = editor.lang.embedbase;\n\n\t\t/**\n\t\t * An embed widget base definition. It predefines a few {@link CKEDITOR.plugins.widget.definition widget definition}\n\t\t * properties such as {@link #mask}, {@link #template} and {@link #pathName} and adds methods related to\n\t\t * content embedding.\n\t\t *\n\t\t * To create a base definition use the {@link CKEDITOR.plugins.embedBase#createWidgetBaseDefinition} method.\n\t\t *\n\t\t * Note: For easier browsing of this class's API you can hide inherited method using the \"Show\" drop-down\n\t\t * on the right-hand side.\n\t\t *\n\t\t * @abstract\n\t\t * @class CKEDITOR.plugins.embedBase.baseDefinition\n\t\t * @extends CKEDITOR.plugins.widget.definition\n\t\t */\n\t\treturn {\n\t\t\tmask: true,\n\t\t\ttemplate: '<div></div>',\n\t\t\tpathName: lang.pathName,\n\n\t\t\t/**\n\t\t\t * Response cache. This cache object will be shared between all instances of this widget.\n\t\t\t *\n\t\t\t * @private\n\t\t\t */\n\t\t\t_cache: {},\n\n\t\t\t/**\n\t\t\t * A regular expression to pre-validate URLs.\n\t\t\t *\n\t\t\t * See:\n\t\t\t *\n\t\t\t * * [https://iframely.com/docs/providers],\n\t\t\t * * {@link #isUrlValid}.\n\t\t\t */\n\t\t\turlRegExp: /^((https?:)?\\/\\/|www\\.)/i,\n\n\t\t\t/**\n\t\t\t * The template used to generate the URL of the content provider. Content provider is a service\n\t\t\t * which the embed widget will request in order to get an [oEmbed](http://www.oembed.com/) response that\n\t\t\t * can be transformed into content which can be embedded in the editor.\n\t\t\t *\n\t\t\t * Example content providers are:\n\t\t\t *\n\t\t\t * * [Iframely](https://iframely.com/),\n\t\t\t * * [Noembed](https://noembed.com/).\n\t\t\t *\n\t\t\t * Both Iframely and Noembed are **proxy** services which support **JSONP requests**, hence they are not limited by the\n\t\t\t * same-origin policy. Unfortunately, usually oEmbed services exposed by real content providers\n\t\t\t * like YouTube or Twitter do not support XHR with CORS or do not support oEmbed at all which makes it\n\t\t\t * impossible or hard to get such content to be embedded in the editor. This problem is solved by proxy content providers\n\t\t\t * like Iframely and Noembed.\n\t\t\t *\n\t\t\t * This property must be defined after creating an embed widget base definition.\n\t\t\t *\n\t\t\t * By default two values are passed to the template:\n\t\t\t *\n\t\t\t * * `{url}` &ndash; The URL of the resource to be embedded.\n\t\t\t * * `{callback}` &ndash; The JSONP callback to be executed.\n\t\t\t *\n\t\t\t * Example value:\n\t\t\t *\n\t\t\t *\t\twidgetDefinition.providerUrl = new CKEDITOR.template(\n\t\t\t *\t\t\t'//ckeditor.iframe.ly/api/oembed?url={url}&callback={callback}'\n\t\t\t *\t\t);\n\t\t\t *\n\t\t\t * @property {CKEDITOR.template} providerUrl\n\t\t\t */\n\n\t\t\tinit: function() {\n\t\t\t\tthis.on( 'sendRequest', function( evt ) {\n\t\t\t\t\tthis._sendRequest( evt.data );\n\t\t\t\t}, this, null, 999 );\n\n\t\t\t\tthis.on( 'handleResponse', function( evt ) {\n\t\t\t\t\tif ( evt.data.html ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar retHtml = this._responseToHtml( evt.data.url, evt.data.response );\n\n\t\t\t\t\tif ( retHtml !== null ) {\n\t\t\t\t\t\tevt.data.html = retHtml;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tevt.data.errorMessage = 'unsupportedUrl';\n\t\t\t\t\t\tevt.cancel();\n\t\t\t\t\t}\n\t\t\t\t}, this, null, 999 );\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Loads content for a given resource URL by requesting the {@link #providerUrl provider}.\n\t\t\t *\n\t\t\t * Usually widgets are controlled by the {@link CKEDITOR.plugins.widget#setData} method. However,\n\t\t\t * loading content is an asynchronous operation due to client-server communication, and it would not\n\t\t\t * be possible to pass callbacks to the {@link CKEDITOR.plugins.widget#setData} method so this new method\n\t\t\t * is defined for embed widgets.\n\t\t\t *\n\t\t\t * This method fires two events that allow to customize widget behavior without changing its code:\n\t\t\t *\n\t\t\t * * {@link #sendRequest},\n\t\t\t * * {@link #handleResponse} (if the request was successful).\n\t\t\t *\n\t\t\t * Note: This method is always asynchronous, even if the cache was hit.\n\t\t\t *\n\t\t\t * Example usage:\n\t\t\t *\n\t\t\t *\t\tvar url = 'https://twitter.com/reinmarpl/status/573118615274315776';\n\t\t\t *\t\twidget.loadContent( url, {\n\t\t\t *\t\t\tcallback: function() {\n\t\t\t *\t\t\t\t// Success. It is a good time to save a snapshot.\n\t\t\t *\t\t\t\teditor.fire( 'saveSnapshot' );\n\t\t\t *\t\t\t\tconsole.log( widget.data.url ); // The above URL. It is only changed\n\t\t\t *\t\t\t\t\t\t\t\t\t\t\t\t// once the content is successfully loaded.\n\t\t\t *\t\t\t},\n\t\t\t *\n\t\t\t *\t\t\terrorCallback: function( message ) {\n\t\t\t *\t\t\t\teditor.showNotification( widget.getErrorMessage( message, url ), 'warning' );\n\t\t\t *\t\t\t}\n\t\t\t *\t\t} );\n\t\t\t *\n\t\t\t * @param {String} url Resource URL to be embedded.\n\t\t\t * @param {Object} opts\n\t\t\t * @param {Function} [opts.callback] Callback called when content was successfully loaded into the editor.\n\t\t\t * @param {Function} [opts.errorCallback] Callback called when an error occurred.\n\t\t\t * @param {String} opts.errorCallback.messageTypeOrMessage See {@link #getErrorMessage}.\n\t\t\t * @param {Boolean} [opts.noNotifications] Do not show notifications (useful when the dialog is open).\n\t\t\t * @returns {CKEDITOR.plugins.embedBase.request}\n\t\t\t */\n\t\t\tloadContent: function( url, opts ) {\n\t\t\t\topts = opts || {};\n\n\t\t\t\tvar that = this,\n\t\t\t\t\tcachedResponse = this._getCachedResponse( url ),\n\t\t\t\t\trequest = {\n\t\t\t\t\t\tnoNotifications: opts.noNotifications,\n\t\t\t\t\t\turl: url,\n\t\t\t\t\t\tcallback: finishLoading,\n\t\t\t\t\t\terrorCallback: function( msg ) {\n\t\t\t\t\t\t\tthat._handleError( request, msg );\n\t\t\t\t\t\t\tif ( opts.errorCallback ) {\n\t\t\t\t\t\t\t\topts.errorCallback( msg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\tif ( cachedResponse ) {\n\t\t\t\t\t// Keep the async nature (it caused a bug the very first day when the loadContent()\n\t\t\t\t\t// was synchronous when cache was hit :D).\n\t\t\t\t\tsetTimeout( function() {\n\t\t\t\t\t\tfinishLoading( cachedResponse );\n\t\t\t\t\t} );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ( !opts.noNotifications ) {\n\t\t\t\t\trequest.task = this._createTask();\n\t\t\t\t}\n\n\t\t\t\t// The execution will be followed by #sendRequest's listener.\n\t\t\t\tthis.fire( 'sendRequest', request );\n\n\t\t\t\tfunction finishLoading( response ) {\n\t\t\t\t\trequest.response = response;\n\n\t\t\t\t\t// Check if widget is still valid.\n\t\t\t\t\tif ( !that.editor.widgets.instances[ that.id ] ) {\n\t\t\t\t\t\tCKEDITOR.warn( 'embedbase-widget-invalid' );\n\n\t\t\t\t\t\tif ( request.task ) {\n\t\t\t\t\t\t\trequest.task.done();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( that._handleResponse( request ) ) {\n\t\t\t\t\t\tthat._cacheResponse( url, response );\n\t\t\t\t\t\tif ( opts.callback ) {\n\t\t\t\t\t\t\topts.callback();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn request;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Checks whether the URL is valid. Usually the content provider makes the final validation\n\t\t\t * as only the provider knows what kind of URLs are accepted. However, to give the user some immediate feedback\n\t\t\t * a synchronous validation is performed using the {@link #urlRegExp} pattern and the {@link #validateUrl} event.\n\t\t\t *\n\t\t\t * @param {String} url The URL to check.\n\t\t\t * @returns {Boolean} Whether the URL is valid (supported).\n\t\t\t */\n\t\t\tisUrlValid: function( url ) {\n\t\t\t\treturn this.urlRegExp.test( url ) && this.fire( 'validateUrl', url ) !== false;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Generates an error message based on the message type (with a possible suffix) or\n\t\t\t * the custom message template.\n\t\t\t *\n\t\t\t * This method is used when showing a notification or an alert (in a dialog) about an error.\n\t\t\t * Usually it is used with an error type which is a string from the `editor.lang.embedbase` object.\n\t\t\t *\n\t\t\t * There are two error types available at the moment: `'unsupportedUrl'` and `'fetchingFailed'`.\n\t\t\t * Additionally, both can be suffixed with `'Given'`. See the language entries to see the difference.\n\t\t\t * Inside the dialog this method is used with a suffix and to generate a notification message it is\n\t\t\t * used without a suffix.\n\t\t\t *\n\t\t\t * Additionally, a custom message may be passed and just like language entries, it can use the `{url}`\n\t\t\t * placeholder.\n\t\t\t *\n\t\t\t * While {@link #handleResponse handling the response} you can set an error message or its type. It will\n\t\t\t * be passed to this method later.\n\t\t\t *\n\t\t\t *\t\twidget.on( 'handleResponse', function( evt ) {\n\t\t\t *\t\t\tif ( evt.data.response.type != 'rich' ) {\n\t\t\t *\t\t\t\tevt.data.errorMessage = '{url} cannot be embedded. Only rich type is supported.';\n\t\t\t *\t\t\t\tevt.cancel();\n\t\t\t *\n\t\t\t *\t\t\t\t// Or:\n\t\t\t *\t\t\t\tevt.data.errorMessage = 'unsupportedUrl.';\n\t\t\t *\t\t\t\tevt.cancel();\n\t\t\t *\t\t\t}\n\t\t\t *\t\t} );\n\t\t\t *\n\t\t\t * If you need to display your own error:\n\t\t\t *\n\t\t\t *\t\teditor.showNotification(\n\t\t\t *\t\t\twidget.getErrorMessage( '{url} cannot be embedded. Only rich type is supported.', wrongUrl )\n\t\t\t *\t\t);\n\t\t\t *\n\t\t\t * Or with a message type:\n\t\t\t *\n\t\t\t *\t\teditor.showNotification(\n\t\t\t *\t\t\twidget.getErrorMessage( 'unsupportedUrl', wrongUrl )\n\t\t\t *\t\t);\n\t\t\t *\n\t\t\t * @param {String} messageTypeOrMessage\n\t\t\t * @param {String} [url]\n\t\t\t * @param {String} [suffix]\n\t\t\t * @returns {String}\n\t\t\t */\n\t\t\tgetErrorMessage: function( messageTypeOrMessage, url, suffix ) {\n\t\t\t\tvar message = editor.lang.embedbase[ messageTypeOrMessage + ( suffix || '' ) ];\n\t\t\t\tif ( !message ) {\n\t\t\t\t\tmessage = messageTypeOrMessage;\n\t\t\t\t}\n\n\t\t\t\treturn new CKEDITOR.template( message ).output( { url: url || '' } );\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Sends the request to the {@link #providerUrl provider} using\n\t\t\t * the {@link CKEDITOR.plugins.embedBase._jsonp JSONP} technique.\n\t\t\t *\n\t\t\t * @private\n\t\t\t * @param {CKEDITOR.plugins.embedBase.request} request\n\t\t\t */\n\t\t\t_sendRequest: function( request ) {\n\t\t\t\tvar that = this,\n\t\t\t\t\tjsonpRequest = Jsonp.sendRequest(\n\t\t\t\t\t\tthis.providerUrl,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\turl: encodeURIComponent( request.url )\n\t\t\t\t\t\t},\n\t\t\t\t\t\trequest.callback,\n\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\trequest.errorCallback( 'fetchingFailed' );\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\trequest.cancel = function() {\n\t\t\t\t\tjsonpRequest.cancel();\n\t\t\t\t\tthat.fire( 'requestCanceled', request );\n\t\t\t\t};\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Handles the response of a successful request.\n\t\t\t *\n\t\t\t * Fires the {@link #handleResponse} event in order to convert the oEmbed response\n\t\t\t * to HTML that can be embedded.\n\t\t\t *\n\t\t\t * If the response can be handled, the {@link #_setContent content is set}.\n\t\t\t *\n\t\t\t * @private\n\t\t\t * @param {CKEDITOR.plugins.embedBase.request} request\n\t\t\t * @returns {Boolean} Whether the response can be handled. Returns `false` if {@link #handleResponse}\n\t\t\t * was canceled or the default listener could not convert oEmbed response into embeddable HTML.\n\t\t\t */\n\t\t\t_handleResponse: function( request ) {\n\t\t\t\tvar evtData = {\n\t\t\t\t\turl: request.url,\n\t\t\t\t\thtml: '',\n\t\t\t\t\tresponse: request.response\n\t\t\t\t};\n\n\t\t\t\tif ( this.fire( 'handleResponse', evtData ) !== false ) {\n\t\t\t\t\tif ( request.task ) {\n\t\t\t\t\t\trequest.task.done();\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._setContent( request.url, evtData.html );\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\trequest.errorCallback( evtData.errorMessage );\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Handles an error. An error can be caused either by a request failure or an unsupported\n\t\t\t * oEmbed response type.\n\t\t\t *\n\t\t\t * @private\n\t\t\t * @param {CKEDITOR.plugins.embedBase.request} request\n\t\t\t * @param {String} messageTypeOrMessage See {@link #getErrorMessage}.\n\t\t\t */\n\t\t\t_handleError: function( request, messageTypeOrMessage ) {\n\t\t\t\tif ( request.task ) {\n\t\t\t\t\trequest.task.cancel();\n\n\t\t\t\t\tif ( !request.noNotifications ) {\n\t\t\t\t\t\teditor.showNotification( this.getErrorMessage( messageTypeOrMessage, request.url ), 'warning' );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns embeddable HTML for an oEmbed response if it is of the `photo`, `video` or `rich` type.\n\t\t\t *\n\t\t\t * @private\n\t\t\t * @param {Object} response The oEmbed response.\n\t\t\t * @returns {String/null} HTML string to be embedded or `null` if this response type is not supported.\n\t\t\t */\n\t\t\t_responseToHtml: function( url, response ) {\n\t\t\t\tif ( response.type == 'photo' ) {\n\t\t\t\t\treturn '<img src=\"' + CKEDITOR.tools.htmlEncodeAttr( response.url ) + '\" ' +\n\t\t\t\t\t\t'alt=\"' + CKEDITOR.tools.htmlEncodeAttr( response.title || '' ) + '\" style=\"max-width:100%;height:auto\" />';\n\t\t\t\t} else if ( response.type == 'video' || response.type == 'rich' ) {\n\t\t\t\t\t// Embedded iframes are added to page's focus list. Adding negative tabindex attribute\n\t\t\t\t\t// removes their ability to be focused by user. (https://dev.ckeditor.com/ticket/14538)\n\t\t\t\t\tresponse.html = response.html.replace( /<iframe/g, '<iframe tabindex=\"-1\"' );\n\n\t\t\t\t\treturn response.html;\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * The very final step of {@link #loadContent content loading}. The `url` data property is changed\n\t\t\t * and the content is embedded ({@link CKEDITOR.plugins.widget#element}'s HTML is set).\n\t\t\t *\n\t\t\t * @private\n\t\t\t * @param {String} url The resource URL.\n\t\t\t * @param {String} content HTML content to be embedded.\n\t\t\t */\n\t\t\t_setContent: function( url, content ) {\n\t\t\t\tthis.setData( 'url', url );\n\t\t\t\tthis.element.setHtml( content );\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Creates a notification aggregator task.\n\t\t\t *\n\t\t\t * @private\n\t\t\t * @returns {CKEDITOR.plugins.notificationAggregator.task}\n\t\t\t */\n\t\t\t_createTask: function() {\n\t\t\t\tif ( !aggregator || aggregator.isFinished() ) {\n\t\t\t\t\taggregator = new CKEDITOR.plugins.notificationAggregator( editor, lang.fetchingMany, lang.fetchingOne );\n\n\t\t\t\t\taggregator.on( 'finished', function() {\n\t\t\t\t\t\taggregator.notification.hide();\n\t\t\t\t\t} );\n\t\t\t\t}\n\n\t\t\t\treturn aggregator.createTask();\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Caches the provider response.\n\t\t\t *\n\t\t\t * @private\n\t\t\t * @param {String} url\n\t\t\t * @param {Object} response\n\t\t\t */\n\t\t\t_cacheResponse: function( url, response ) {\n\t\t\t\tthis._cache[ url ] = response;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns the cached response.\n\t\t\t *\n\t\t\t * @private\n\t\t\t * @param {String} url\n\t\t\t * @returns {Object/undefined} Response or `undefined` if the cache was missed.\n\t\t\t */\n\t\t\t_getCachedResponse: function( url ) {\n\t\t\t\treturn this._cache[ url ];\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Fired by the {@link #isUrlValid} method. Cancel the event to make the URL invalid.\n\t\t *\n\t\t * @event validateUrl\n\t\t * @param {String} data The URL being validated.\n\t\t */\n\n\t\t/**\n\t\t * Fired by the {@link #loadContent} method to dispatch a request to the provider.\n\t\t * You can cancel this event and send the request using a different technique.\n\t\t * By default, if the event is not stopped or canceled a request will be sent\n\t\t * using the JSONP technique.\n\t\t *\n\t\t *\t\twidget.on( 'sendRequest', function( evt ) {\n\t\t *\t\t\tvar request = evt.data;\n\t\t *\n\t\t *\t\t\t// Send the request using a technique of your choice (XHR with CORS for instance).\n\t\t *\t\t\tmyApp.requestOembedProvider( request.url, function( err, response ) {\n\t\t *\t\t\t\tif ( err ) {\n\t\t *\t\t\t\t\trequest.errorCallback( err );\n\t\t *\t\t\t\t} else {\n\t\t *\t\t\t\t\trequest.callback( response );\n\t\t *\t\t\t\t}\n\t\t *\t\t\t} );\n\t\t *\n\t\t *\t\t\t// Do not call other listeners, so the default behavior (JSONP request)\n\t\t *\t\t\t// will not be executed.\n\t\t *\t\t\tevt.stop();\n\t\t *\t\t} );\n\t\t *\n\t\t * @event sendRequest\n\t\t * @param {CKEDITOR.plugins.embedBase.request} data\n\t\t */\n\n\t\t/**\n\t\t * Fired after receiving a response from the {@link #providerUrl provider}.\n\t\t * This event listener job is to turn the oEmbed response to embeddable HTML by setting\n\t\t * `evt.data.html`.\n\t\t *\n\t\t *\t\twidget.on( 'handleReaponse', function( evt ) {\n\t\t *\t\t\tevt.data.html = customOembedToHtmlConverter( evt.data.response );\n\t\t *\t\t} );\n\t\t *\n\t\t * This event can also be canceled to indicate that the response cannot be handled. In such\n\t\t * case the `evt.data.errorMessage` must be set (see {@link #getErrorMessage}).\n\t\t *\n\t\t *\t\twidget.on( 'handleReaponse', function( evt ) {\n\t\t *\t\t\tif ( evt.data.response.type == 'photo' ) {\n\t\t *\t\t\t\t// Will display the editor.lang.embedbase.unsupportedUrl(Given) message.\n\t\t *\t\t\t\tevt.data.errorMessage = 'unsupportedUrl';\n\t\t *\t\t\t\tevt.cancel();\n\t\t *\t\t\t}\n\t\t *\t\t} );\n\t\t *\n\t\t * This event has a default late-listener (with a priority of `999`) that, if `evt.data.html` has not\n\t\t * been set yet, will try to handle the response by using the {@link #_responseToHtml} method.\n\t\t *\n\t\t * @event handleResponse\n\t\t * @param {Object} data\n\t\t * @param {String} data.url The resource URL.\n\t\t * @param {Object} data.response The oEmbed response.\n\t\t * @param {String} [data.html=''] The HTML which will be embedded.\n\t\t * @param {String} [data.errorMessage] The error message or message type (see {@link #getErrorMessage})\n\t\t * that must be set if this event is canceled to indicate an unsupported oEmbed response.\n\t\t */\n\t}\n\n\t/**\n\t * Class representing the request object. It is created by the {@link CKEDITOR.plugins.embedBase.baseDefinition#loadContent}\n\t * method and is passed to other methods and events of this class.\n\t *\n\t * @abstract\n\t * @class CKEDITOR.plugins.embedBase.request\n\t */\n\n\t/**\n\t * The resource URL to be embedded (not the {@link CKEDITOR.plugins.embedBase.baseDefinition#providerUrl provider URL}).\n\t *\n\t * @property {String} url\n\t */\n\n\t/**\n\t * Success callback to be executed once a response to a request is received.\n\t *\n\t * @property {Function} [callback]\n\t * @param {Object} response The response object.\n\t */\n\n\t/**\n\t * Callback executed in case of an error.\n\t *\n\t * @property {Function} [errorCallback]\n\t * @param {String} messageTypeOrMessage See {@link CKEDITOR.plugins.embedBase.baseDefinition#getErrorMessage}.\n\t */\n\n\t/**\n\t * Task that should be resolved once the request is done.\n\t *\n\t * @property {CKEDITOR.plugins.notificationAggregator.task} [task]\n\t */\n\n\t/**\n\t * Response object. It is set once a response is received.\n\t *\n\t * @property {Object} [response]\n\t */\n\n\t/**\n\t * Cancels the request.\n\t *\n\t * @method cancel\n\t */\n\n\tCKEDITOR.plugins.embedBase = {\n\t\tcreateWidgetBaseDefinition: createWidgetBaseDefinition,\n\t\t_jsonp: Jsonp\n\t};\n\n} )();\n"]}