{"version":3,"file":"plugin.js","names":["CKEDITOR","plugins","add","icons","hidpi","requires","onLoad","this","registerOembedTag","init","editor","widgetDefinition","embedBase","createWidgetBaseDefinition","origInit","tools","extend","dialog","button","lang","embedbase","allowedContent","requiredContent","styleableElements","providerUrl","template","config","embed_provider","that","call","once","data","loadOnReady","loadContent","url","callback","setData","fire","upcast","element","name","div","text","children","type","NODE_TEXT","value","htmlParser","replaceWith","attributes","downcast","ret","widgets","dtd","oembed"],"sources":["embedsemantic/plugin.js"],"mappings":";;;;CAKA,WACC,aAEAA,SAASC,QAAQC,IAAK,gBAAiB,CACtCC,MAAO,gBACPC,OAAO,EACPC,SAAU,YAEVC,OAAQ,WACPC,KAAKC,mBACN,EAEAC,KAAM,SAAUC,GACf,IAAIC,EAAmBX,SAASC,QAAQW,UAAUC,2BAA4BH,GAC7EI,EAAWH,EAAiBF,KAE7BT,SAASe,MAAMC,OAAQL,EAAkB,CAExCM,OAAQ,YACRC,OAAQR,EAAOS,KAAKC,UAAUF,OAC9BG,eAAgB,SAChBC,gBAAiB,SACjBC,kBAAmB,SAEnBC,YAAa,IAAIxB,SAASyB,SACzBf,EAAOgB,OAAOC,gBACd,iEAGDlB,KAAM,WACL,IAAImB,EAAOrB,KAEXO,EAASe,KAAMtB,MAGfA,KAAKuB,KAAM,SAAS,WAGdvB,KAAKwB,KAAKC,aACdzB,KAAK0B,YAAa1B,KAAKwB,KAAKG,IAAK,CAChCC,SAAU,WAKTP,EAAKQ,QAAS,eAAe,GAC7B1B,EAAO2B,KAAM,iBACd,GAGH,GACD,EAEAC,OAAQ,SAAUC,EAASR,GAC1B,GAAqB,UAAhBQ,EAAQC,KAAb,CAIA,IACCC,EADGC,EAAOH,EAAQI,SAAU,GAG7B,OAAKD,GAAQA,EAAKE,MAAQ5C,SAAS6C,WAAaH,EAAKI,OACpDf,EAAKG,IAAMQ,EAAKI,MAChBf,EAAKC,aAAc,EACnBS,EAAM,IAAIzC,SAAS+C,WAAWR,QAAS,OACvCA,EAAQS,YAAaP,GAGrBA,EAAIQ,WAAoB,MAAIV,EAAQU,WAAoB,MAEjDR,QATR,CALA,CAgBD,EAEAS,SAAU,SAAUX,GACnB,IAAIY,EAAM,IAAInD,SAAS+C,WAAWR,QAAS,UAQ3C,OAPAY,EAAIjD,IAAK,IAAIF,SAAS+C,WAAWL,KAAMnC,KAAKwB,KAAKG,MAG5CK,EAAQU,WAAoB,QAChCE,EAAIF,WAAoB,MAAIV,EAAQU,WAAoB,OAGlDE,CACR,IACE,GAEHzC,EAAO0C,QAAQlD,IAAK,gBAAiBS,EACtC,EAGAH,kBAAmB,WAClB,IACCgC,EADGa,EAAMrD,SAASqD,IAQnB,IAAMb,KAJNa,EAAIC,OAAS,CAAE,IAAK,GAIND,EACRA,EAAKb,GAAOC,MAChBY,EAAKb,GAAOc,OAAS,EAGxB,GAGA,CA5GF","sourcesContent":["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n( function() {\n\t'use strict';\n\n\tCKEDITOR.plugins.add( 'embedsemantic', {\n\t\ticons: 'embedsemantic', // %REMOVE_LINE_CORE%\n\t\thidpi: true, // %REMOVE_LINE_CORE%\n\t\trequires: 'embedbase',\n\n\t\tonLoad: function() {\n\t\t\tthis.registerOembedTag();\n\t\t},\n\n\t\tinit: function( editor ) {\n\t\t\tvar widgetDefinition = CKEDITOR.plugins.embedBase.createWidgetBaseDefinition( editor ),\n\t\t\t\torigInit = widgetDefinition.init;\n\n\t\t\tCKEDITOR.tools.extend( widgetDefinition, {\n\t\t\t\t// Use a dialog exposed by the embedbase plugin.\n\t\t\t\tdialog: 'embedBase',\n\t\t\t\tbutton: editor.lang.embedbase.button,\n\t\t\t\tallowedContent: 'oembed',\n\t\t\t\trequiredContent: 'oembed',\n\t\t\t\tstyleableElements: 'oembed',\n\t\t\t\t// Share config with the embed plugin.\n\t\t\t\tproviderUrl: new CKEDITOR.template(\n\t\t\t\t\teditor.config.embed_provider ||\n\t\t\t\t\t'//ckeditor.iframe.ly/api/oembed?url={url}&callback={callback}'\n\t\t\t\t),\n\n\t\t\t\tinit: function() {\n\t\t\t\t\tvar that = this;\n\n\t\t\t\t\torigInit.call( this );\n\n\t\t\t\t\t// Need to wait for #ready with the initial content loading, because on #init there's no data yet.\n\t\t\t\t\tthis.once( 'ready', function() {\n\t\t\t\t\t\t// When widget is created using dialog, the dialog's code will handle loading the content\n\t\t\t\t\t\t// (because it handles success and error), so do load the content only when loading data.\n\t\t\t\t\t\tif ( this.data.loadOnReady ) {\n\t\t\t\t\t\t\tthis.loadContent( this.data.url, {\n\t\t\t\t\t\t\t\tcallback: function() {\n\t\t\t\t\t\t\t\t\t// Do not load the content again on widget's next initialization (e.g. after undo or paste).\n\t\t\t\t\t\t\t\t\t// Plus, this is a small trick that we change loadOnReady now, inside the callback.\n\t\t\t\t\t\t\t\t\t// It guarantees that if the content was not loaded (an error occurred or someone\n\t\t\t\t\t\t\t\t\t// undid/copied sth to fast) the content will be loaded on the next initialization.\n\t\t\t\t\t\t\t\t\tthat.setData( 'loadOnReady', false );\n\t\t\t\t\t\t\t\t\teditor.fire( 'updateSnapshot' );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t},\n\n\t\t\t\tupcast: function( element, data ) {\n\t\t\t\t\tif ( element.name != 'oembed' ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar text = element.children[ 0 ],\n\t\t\t\t\t\tdiv;\n\n\t\t\t\t\tif ( text && text.type == CKEDITOR.NODE_TEXT && text.value ) {\n\t\t\t\t\t\tdata.url = text.value;\n\t\t\t\t\t\tdata.loadOnReady = true;\n\t\t\t\t\t\tdiv = new CKEDITOR.htmlParser.element( 'div' );\n\t\t\t\t\t\telement.replaceWith( div );\n\n\t\t\t\t\t\t// Transfer widget classes from data to widget element (https://dev.ckeditor.com/ticket/13199).\n\t\t\t\t\t\tdiv.attributes[ 'class' ] = element.attributes[ 'class' ];\n\n\t\t\t\t\t\treturn div;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tdowncast: function( element ) {\n\t\t\t\t\tvar ret = new CKEDITOR.htmlParser.element( 'oembed' );\n\t\t\t\t\tret.add( new CKEDITOR.htmlParser.text( this.data.url ) );\n\n\t\t\t\t\t// Transfer widget classes from widget element back to data (https://dev.ckeditor.com/ticket/13199).\n\t\t\t\t\tif ( element.attributes[ 'class' ] ) {\n\t\t\t\t\t\tret.attributes[ 'class' ] = element.attributes[ 'class' ];\n\t\t\t\t\t}\n\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}, true );\n\n\t\t\teditor.widgets.add( 'embedSemantic', widgetDefinition );\n\t\t},\n\n\t\t// Extends CKEDITOR.dtd so editor accepts <oembed> tag.\n\t\tregisterOembedTag: function() {\n\t\t\tvar dtd = CKEDITOR.dtd,\n\t\t\t\tname;\n\n\t\t\t// The oembed tag may contain text only.\n\t\t\tdtd.oembed = { '#': 1 };\n\n\t\t\t// Register oembed tag as allowed child, in each tag that can contain a div.\n\t\t\t// It also registers the oembed tag in objects like $block, $blockLimit, etc.\n\t\t\tfor ( name in dtd ) {\n\t\t\t\tif ( dtd[ name ].div ) {\n\t\t\t\t\tdtd[ name ].oembed = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} );\n\n} )();\n"]}