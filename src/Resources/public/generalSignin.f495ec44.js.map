{"version":3,"file":"generalSignin.f495ec44.js","mappings":"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","sources":["webpack://init-cms-bundle/./node_modules/@simplewebauthn/browser/dist/bundle/index.js","webpack://init-cms-bundle/./assets/cms/authentication/webauthn/client.js","webpack://init-cms-bundle/./assets/cms/authentication/sign-in/general.js"],"sourcesContent":["/* [@simplewebauthn/browser@9.0.1] */\nfunction utf8StringToBuffer(value) {\n    return new TextEncoder().encode(value);\n}\n\nfunction bufferToBase64URLString(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let str = '';\n    for (const charCode of bytes) {\n        str += String.fromCharCode(charCode);\n    }\n    const base64String = btoa(str);\n    return base64String.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nfunction base64URLStringToBuffer(base64URLString) {\n    const base64 = base64URLString.replace(/-/g, '+').replace(/_/g, '/');\n    const padLength = (4 - (base64.length % 4)) % 4;\n    const padded = base64.padEnd(base64.length + padLength, '=');\n    const binary = atob(padded);\n    const buffer = new ArrayBuffer(binary.length);\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return buffer;\n}\n\nfunction browserSupportsWebAuthn() {\n    return (window?.PublicKeyCredential !== undefined &&\n        typeof window.PublicKeyCredential === 'function');\n}\n\nfunction toPublicKeyCredentialDescriptor(descriptor) {\n    const { id } = descriptor;\n    return {\n        ...descriptor,\n        id: base64URLStringToBuffer(id),\n        transports: descriptor.transports,\n    };\n}\n\nfunction isValidDomain(hostname) {\n    return (hostname === 'localhost' ||\n        /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n\nclass WebAuthnError extends Error {\n    constructor({ message, code, cause, name, }) {\n        super(message, { cause });\n        this.name = name ?? cause.name;\n        this.code = code;\n    }\n}\n\nfunction identifyRegistrationError({ error, options, }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal instanceof AbortSignal) {\n            return new WebAuthnError({\n                message: 'Registration ceremony was sent an abort signal',\n                code: 'ERROR_CEREMONY_ABORTED',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'ConstraintError') {\n        if (publicKey.authenticatorSelection?.requireResidentKey === true) {\n            return new WebAuthnError({\n                message: 'Discoverable credentials were required but no available authenticator supported it',\n                code: 'ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT',\n                cause: error,\n            });\n        }\n        else if (publicKey.authenticatorSelection?.userVerification === 'required') {\n            return new WebAuthnError({\n                message: 'User verification was required but no available authenticator supported it',\n                code: 'ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'InvalidStateError') {\n        return new WebAuthnError({\n            message: 'The authenticator was previously registered',\n            code: 'ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED',\n            cause: error,\n        });\n    }\n    else if (error.name === 'NotAllowedError') {\n        return new WebAuthnError({\n            message: error.message,\n            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n            cause: error,\n        });\n    }\n    else if (error.name === 'NotSupportedError') {\n        const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param) => param.type === 'public-key');\n        if (validPubKeyCredParams.length === 0) {\n            return new WebAuthnError({\n                message: 'No entry in pubKeyCredParams was of type \"public-key\"',\n                code: 'ERROR_MALFORMED_PUBKEYCREDPARAMS',\n                cause: error,\n            });\n        }\n        return new WebAuthnError({\n            message: 'No available authenticator supported any of the specified pubKeyCredParams algorithms',\n            code: 'ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG',\n            cause: error,\n        });\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError({\n                message: `${window.location.hostname} is an invalid domain`,\n                code: 'ERROR_INVALID_DOMAIN',\n                cause: error,\n            });\n        }\n        else if (publicKey.rp.id !== effectiveDomain) {\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rp.id}\" is invalid for this domain`,\n                code: 'ERROR_INVALID_RP_ID',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'TypeError') {\n        if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n            return new WebAuthnError({\n                message: 'User ID was not between 1 and 64 characters',\n                code: 'ERROR_INVALID_USER_ID_LENGTH',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError({\n            message: 'The authenticator was unable to process the specified options, or could not create a new credential',\n            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n            cause: error,\n        });\n    }\n    return error;\n}\n\nclass BaseWebAuthnAbortService {\n    createNewAbortSignal() {\n        if (this.controller) {\n            const abortError = new Error('Cancelling existing WebAuthn API call for new one');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n        }\n        const newController = new AbortController();\n        this.controller = newController;\n        return newController.signal;\n    }\n    cancelCeremony() {\n        if (this.controller) {\n            const abortError = new Error('Manually cancelling existing WebAuthn API call');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n            this.controller = undefined;\n        }\n    }\n}\nconst WebAuthnAbortService = new BaseWebAuthnAbortService();\n\nconst attachments = ['cross-platform', 'platform'];\nfunction toAuthenticatorAttachment(attachment) {\n    if (!attachment) {\n        return;\n    }\n    if (attachments.indexOf(attachment) < 0) {\n        return;\n    }\n    return attachment;\n}\n\nasync function startRegistration(creationOptionsJSON) {\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    const publicKey = {\n        ...creationOptionsJSON,\n        challenge: base64URLStringToBuffer(creationOptionsJSON.challenge),\n        user: {\n            ...creationOptionsJSON.user,\n            id: utf8StringToBuffer(creationOptionsJSON.user.id),\n        },\n        excludeCredentials: creationOptionsJSON.excludeCredentials?.map(toPublicKeyCredentialDescriptor),\n    };\n    const options = { publicKey };\n    options.signal = WebAuthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.create(options));\n    }\n    catch (err) {\n        throw identifyRegistrationError({ error: err, options });\n    }\n    if (!credential) {\n        throw new Error('Registration was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let transports = undefined;\n    if (typeof response.getTransports === 'function') {\n        transports = response.getTransports();\n    }\n    let responsePublicKeyAlgorithm = undefined;\n    if (typeof response.getPublicKeyAlgorithm === 'function') {\n        try {\n            responsePublicKeyAlgorithm = response.getPublicKeyAlgorithm();\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getPublicKeyAlgorithm()', error);\n        }\n    }\n    let responsePublicKey = undefined;\n    if (typeof response.getPublicKey === 'function') {\n        try {\n            const _publicKey = response.getPublicKey();\n            if (_publicKey !== null) {\n                responsePublicKey = bufferToBase64URLString(_publicKey);\n            }\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getPublicKey()', error);\n        }\n    }\n    let responseAuthenticatorData;\n    if (typeof response.getAuthenticatorData === 'function') {\n        try {\n            responseAuthenticatorData = bufferToBase64URLString(response.getAuthenticatorData());\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getAuthenticatorData()', error);\n        }\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            attestationObject: bufferToBase64URLString(response.attestationObject),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            transports,\n            publicKeyAlgorithm: responsePublicKeyAlgorithm,\n            publicKey: responsePublicKey,\n            authenticatorData: responseAuthenticatorData,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\nfunction warnOnBrokenImplementation(methodName, cause) {\n    console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${methodName}. You should report this error to them.\\n`, cause);\n}\n\nfunction bufferToUTF8String(value) {\n    return new TextDecoder('utf-8').decode(value);\n}\n\nfunction browserSupportsWebAuthnAutofill() {\n    const globalPublicKeyCredential = window\n        .PublicKeyCredential;\n    if (globalPublicKeyCredential.isConditionalMediationAvailable === undefined) {\n        return new Promise((resolve) => resolve(false));\n    }\n    return globalPublicKeyCredential.isConditionalMediationAvailable();\n}\n\nfunction identifyAuthenticationError({ error, options, }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal instanceof AbortSignal) {\n            return new WebAuthnError({\n                message: 'Authentication ceremony was sent an abort signal',\n                code: 'ERROR_CEREMONY_ABORTED',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'NotAllowedError') {\n        return new WebAuthnError({\n            message: error.message,\n            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n            cause: error,\n        });\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError({\n                message: `${window.location.hostname} is an invalid domain`,\n                code: 'ERROR_INVALID_DOMAIN',\n                cause: error,\n            });\n        }\n        else if (publicKey.rpId !== effectiveDomain) {\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rpId}\" is invalid for this domain`,\n                code: 'ERROR_INVALID_RP_ID',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError({\n            message: 'The authenticator was unable to process the specified options, or could not create a new assertion signature',\n            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n            cause: error,\n        });\n    }\n    return error;\n}\n\nasync function startAuthentication(requestOptionsJSON, useBrowserAutofill = false) {\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    let allowCredentials;\n    if (requestOptionsJSON.allowCredentials?.length !== 0) {\n        allowCredentials = requestOptionsJSON.allowCredentials?.map(toPublicKeyCredentialDescriptor);\n    }\n    const publicKey = {\n        ...requestOptionsJSON,\n        challenge: base64URLStringToBuffer(requestOptionsJSON.challenge),\n        allowCredentials,\n    };\n    const options = {};\n    if (useBrowserAutofill) {\n        if (!(await browserSupportsWebAuthnAutofill())) {\n            throw Error('Browser does not support WebAuthn autofill');\n        }\n        const eligibleInputs = document.querySelectorAll('input[autocomplete$=\\'webauthn\\']');\n        if (eligibleInputs.length < 1) {\n            throw Error('No <input> with \"webauthn\" as the only or last value in its `autocomplete` attribute was detected');\n        }\n        options.mediation = 'conditional';\n        publicKey.allowCredentials = [];\n    }\n    options.publicKey = publicKey;\n    options.signal = WebAuthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.get(options));\n    }\n    catch (err) {\n        throw identifyAuthenticationError({ error: err, options });\n    }\n    if (!credential) {\n        throw new Error('Authentication was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let userHandle = undefined;\n    if (response.userHandle) {\n        userHandle = bufferToUTF8String(response.userHandle);\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            authenticatorData: bufferToBase64URLString(response.authenticatorData),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            signature: bufferToBase64URLString(response.signature),\n            userHandle,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\n\nfunction platformAuthenticatorIsAvailable() {\n    if (!browserSupportsWebAuthn()) {\n        return new Promise((resolve) => resolve(false));\n    }\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n}\n\nexport { WebAuthnAbortService, WebAuthnError, base64URLStringToBuffer, browserSupportsWebAuthn, browserSupportsWebAuthnAutofill, bufferToBase64URLString, platformAuthenticatorIsAvailable, startAuthentication, startRegistration };\n","import { startRegistration, startAuthentication } from '@simplewebauthn/browser';\n\nexport async function _fetch(path, payload = '') {\n    const headers = {\n        'X-Requested-With': 'XMLHttpRequest',\n        'Content-Type': 'application/json'\n    };\n    if (payload && !(payload instanceof FormData)) {\n        payload = JSON.stringify(payload);\n    }\n    const res = await fetch(path, {\n        method: 'POST',\n        credentials: 'same-origin',\n        headers: headers,\n        body: payload,\n    });\n    if (res.status === 200 || res.status === 201) {\n        // Server authentication succeeded\n        return res.json();\n    } else {\n        // Server authentication failed\n        const result = await res.json();\n\n        if(result.message){\n            throw new Error(result.message);\n        }\n\n        throw new Error(result.error);\n    }\n}\n\n\nexport async function registerCredential(username, displayName) {\n\n    let data = {\n        username: username,\n        displayName: displayName,\n        authenticatorSelection: {\n            userVerification: 'preferred',\n        },\n    }\n\n    const options = await _fetch('/admin/register/options', data);\n\n    let attResp;\n    try {\n        // Pass the options to the authenticator and wait for a response\n        attResp = await startRegistration(options);\n    } catch (error) {\n\n        throw error;\n    }\n\n    return await _fetch(CMSRouting.generate('initcms_webauthn_register_response'), attResp);\n\n}\nexport async function authenticate(username) {\n    let payload = {\n        requireUserVerification: 'preferred',\n    }\n\n    if(username){\n        payload.username = username;\n    }\n    const options = await _fetch('/admin/assertion/options', payload);\n    if(username && options.allowCredentials === undefined){\n        throw new Error('no_credentials');\n    }\n\n\n    let asseResp;\n    try {\n        // Pass the options to the authenticator and wait for a response\n        asseResp = await startAuthentication(options);\n    } catch (error) {\n        throw error;\n    }\n\n    return _fetch('/admin/assertion', asseResp);\n}\n\nexport async function unregisterCredential(credId) {\n    return _fetch(CMSRouting.generate('admin_networking_initcms_user_remove_webauthn_key') + `?credId=${encodeURIComponent(credId)}`);\n}\n\nexport async function updateCredential(credId, name) {\n    return _fetch(CMSRouting.generate('admin_networking_initcms_user_rename_webauthn_key') + `?credId=${encodeURIComponent(credId)}&name=${encodeURIComponent(name)}`);\n}\n","\"use strict\";\n\n\nimport {authenticate} from \"../webauthn/client\";\nimport { browserSupportsWebAuthnAutofill, platformAuthenticatorIsAvailable } from '@simplewebauthn/browser';\nlet KTSigninGeneral = function () {\n    // Elements\n    let form;\n    let submitButton;\n    let validator;\n    let signInWithPasskeyButton;\n    let signInWithUsernameAndPasswordLink;\n    let signInWithPasskeyContainer;\n    let signInWithUsernameAndPasswordContainer;\n\n    const lang = localStorage.getItem(\"kt_auth_lang\")??document.getElementsByTagName('html')[0].getAttribute('lang');\n\n    const texts = {\n        'en': {\n            'email_invalid': 'The value is not a valid email address',\n            'email_empty': 'Email address is required',\n            'password_empty': 'The password is required',\n            'login_success': 'You have successfully logged in!',\n            'login_error': 'Sorry, looks like there are some errors detected, please try again.',\n            'ok': 'Ok, got it!'\n        },\n        'de': {\n            'email_invalid': 'Der Wert ist keine gültige E-Mail-Adresse',\n            'email_empty': 'E-Mail-Adresse ist erforderlich',\n            'password_empty': 'Das Passwort ist erforderlich',\n            'login_success': 'Sie haben sich erfolgreich angemeldet!',\n            'login_error': 'Entschuldigung, es scheint, dass einige Fehler erkannt wurden, bitte versuchen Sie es erneut.',\n            'ok': 'Ok, verstanden!'\n        },\n        'fr': {\n            'email_invalid': 'La valeur n\\'est pas une adresse e-mail valide',\n            'email_empty': 'L\\'adresse e-mail est requise',\n            'password_empty': 'Le mot de passe est requis',\n            'login_success': 'Vous vous êtes connecté avec succès!',\n            'login_error': 'Désolé, il semble qu\\'il y ait des erreurs détectées, veuillez réessayer.',\n            'ok': 'Ok, compris!'\n        },\n        'it': {\n            'email_invalid': 'Il valore non è un indirizzo e-mail valido',\n            'email_empty': 'L\\'indirizzo e-mail è richiesto',\n            'password_empty': 'La password è richiesta',\n            'login_success': 'L\\'accesso è stato effettuato con successo!',\n            'login_error': 'Spiacente, sembra che siano stati rilevati degli errori, si prega di riprovare.',\n            'ok': 'Ok, capito!'\n        },\n    }\n\n    let translate = function (text) {\n\n        switch (lang) {\n            case 'German':\n            case 'de':\n                return texts['de'][text];\n            case 'Italian':\n            case 'it':\n                return texts['it'][text];\n            case 'French':\n            case 'fr':\n                return texts['fr'][text];\n            default:\n                return texts['en'][text];\n\n        }\n    }\n\n    // Handle form\n    let handleValidation = function (e) {\n        // Init form validation rules. For more info check the FormValidation plugin's official documentation:https://formvalidation.io/\n        validator = FormValidation.formValidation(\n            form,\n            {\n                fields: {\n                    '_username': {\n                        validators: {\n                            regexp: {\n                                regexp: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$|^sysadmin$/,\n                                message: translate('email_invalid'),\n                            },\n                            notEmpty: {\n                                message: translate('email_empty')\n                            }\n                        }\n                    },\n                    '_password': {\n                        validators: {\n                            notEmpty: {\n                                message: translate('password_empty')\n                            }\n                        }\n                    }\n                },\n                plugins: {\n                    trigger: new FormValidation.plugins.Trigger(),\n                    bootstrap: new FormValidation.plugins.Bootstrap5({\n                        rowSelector: '.fv-row',\n                        eleInvalidClass: '',  // comment to enable invalid state icons\n                        eleValidClass: '' // comment to enable valid state icons\n                    })\n                }\n            }\n        );\n    }\n\n\n    let handleSubmitAjax = async function (e) {\n        // Handle form submit\n        submitButton.addEventListener('click', function (e) {\n            // Prevent button default action\n            e.preventDefault();\n\n            // Validate form\n            validator.validate().then(function (status) {\n                if (status === 'Valid') {\n                    // Show loading indication\n                    submitButton.setAttribute('data-kt-indicator', 'on');\n\n                    // Disable button to avoid multiple click\n                    submitButton.disabled = true;\n                    // form.submit();\n                    // return;\n\n                    let formData = new FormData(form);\n\n                    let loginInfo = {}\n                    formData.forEach( (value, key) => {\n                        loginInfo[key] = value;\n                    })\n\n                    axios.post(CMSRouting.generate('cms_api_login'), loginInfo, {...axiosConfig})\n                        .then((response) => {\n                            submitButton.disabled = false;\n                            submitButton.removeAttribute('data-kt-indicator');\n                            let redirect = response.data.redirect;\n                            Swal.fire({\n                                    text: translate('login_success'),\n                                    icon: \"success\",\n                                    timer: 1000,\n                                    showConfirmButton: false,\n                                }).then(() => {\n                                    let host =  window.location.protocol + '//' + window.location.host\n                                    if(redirect.indexOf(host) === -1 || redirect.indexOf('http') === -1) {\n                                        redirect = host + redirect\n                                    }\n                                    location.href = redirect\n                                });\n                        })\n                        .catch((error) => {\n                            submitButton.disabled = false;\n                            submitButton.removeAttribute('data-kt-indicator');\n                            let data = error.response.data\n\n                            Swal.fire({\n                                text: data.error,\n                                icon: \"error\",\n                                buttonsStyling: false,\n                                confirmButtonText: translate('ok'),\n                                customClass: {\n                                    confirmButton: \"btn btn-primary\"\n                                }\n                            });\n                            submitButton.disabled = false;\n                        })\n\n                } else {\n                    // Show error popup. For more info check the plugin's official documentation: https://sweetalert2.github.io/\n                    Swal.fire({\n                        text: translate('login_error'),\n                        icon: \"error\",\n                        buttonsStyling: false,\n                        confirmButtonText: translate('ok'),\n                        customClass: {\n                            confirmButton: \"btn btn-primary\"\n                        }\n                    });\n                }\n            });\n        });\n    }\n\n    let isValidUrl = function(url) {\n        try {\n            new URL(url);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    let webauthnSignin = async function(username){\n        try{\n            // Is conditional UI available in this browser?\n            const cma = await PublicKeyCredential.isConditionalMediationAvailable();\n            if (cma) {\n                const result = await authenticate(username);\n                if (result && 'ok' === result.status) {\n                    return location.href = document.querySelector('#redirect_route').value\n                }\n\n\n                throw new Error(result)\n            }\n        }catch (e) {\n            let message = e.message;\n\n            if(e.name === 'Error'){\n                message = translate('login_error');\n            }\n\n            if(e.name === 'NotAllowedError'){\n                return signInWithUsernameAndPasswordLink.click()\n            }\n\n            if(e.message === 'no_credentials'){\n                return signInWithUsernameAndPasswordLink.click()\n            }\n\n            Swal.fire({\n                text: message,\n                icon: \"error\",\n                buttonsStyling: false,\n                confirmButtonText: translate('ok'),\n                customClass: {\n                    confirmButton: \"btn btn-primary\"\n                }\n            });\n        }\n    }\n\n    // Public functions\n    return {\n        // Initialization\n        init: function () {\n            form = document.querySelector('#kt_sign_in_form');\n            submitButton = document.querySelector('#kt_sign_in_submit');\n            signInWithUsernameAndPasswordContainer = document.querySelector('#kt_sign_in_with_username_and_password_container');\n            let webauthnEnabled = document.querySelector(\"meta[name='webauthn-enabled']\").getAttribute(\"content\");\n\n            if (\n                webauthnEnabled &&\n                window.PublicKeyCredential &&\n                PublicKeyCredential.isConditionalMediationAvailable\n            ) {\n                signInWithPasskeyButton = document.querySelector('#kt_sign_in_with_passkey');\n                signInWithUsernameAndPasswordLink = document.querySelector('#kt_sign_in_with_username_and_password');\n                signInWithPasskeyContainer = document.querySelector('#kt_sign_in_with_passkey_container');\n\n\n                let typingTimer;                //timer identifier\n                let doneTypingInterval = 1000;  //time in ms (5 seconds)\n                let usernameInput = document.querySelector('#username');\n                const usernameEvent = () => {\n                    clearTimeout(typingTimer);\n                    if (usernameInput.value) {\n                        typingTimer = setTimeout(doneTyping, doneTypingInterval);\n                    }\n                }\n\n                let eventListener = usernameInput.addEventListener('keyup', usernameEvent);\n\n                function doneTyping () {\n                    signInWithPasskeyButton.click()\n                }\n\n                signInWithPasskeyButton.addEventListener('click', function (e) {\n                    e.preventDefault();\n                    try {\n                        webauthnSignin(usernameInput.value);\n                    } catch (e) {\n\n                        // A NotAllowedError indicates that the user canceled the operation.\n                        if (e.name !== \"NotAllowedError\") {\n                            //CMSAdmin.createInitCmsMessageBox('error', e.message);\n                        }\n                    }\n                })\n\n                signInWithUsernameAndPasswordLink.addEventListener('click', function (e) {\n                    e.preventDefault();\n                    usernameInput.removeEventListener('keyup', usernameEvent);\n                    signInWithPasskeyContainer.classList.add('d-none');\n                    signInWithUsernameAndPasswordContainer.classList.remove('d-none');\n\n                })\n            }\n\n            handleValidation();\n\n            if (isValidUrl(submitButton.closest('form').getAttribute('action'))) {\n                handleSubmitAjax(); // use for ajax submit\n            }\n        }\n    };\n}();\n\n// On document ready\ndocument.addEventListener('DOMContentLoaded', () => {\n    KTSigninGeneral.init();\n});\n"],"names":["bufferToBase64URLString","buffer","bytes","Uint8Array","str","charCode","String","fromCharCode","btoa","replace","base64URLStringToBuffer","base64URLString","base64","padLength","length","padded","padEnd","binary","atob","ArrayBuffer","i","charCodeAt","browserSupportsWebAuthn","undefined","window","PublicKeyCredential","toPublicKeyCredentialDescriptor","descriptor","id","transports","isValidDomain","hostname","test","WebAuthnError","Error","constructor","message","code","cause","name","super","this","WebAuthnAbortService","createNewAbortSignal","controller","abortError","abort","newController","AbortController","signal","cancelCeremony","attachments","toAuthenticatorAttachment","attachment","indexOf","async","startAuthentication","requestOptionsJSON","useBrowserAutofill","allowCredentials","map","publicKey","challenge","options","globalPublicKeyCredential","isConditionalMediationAvailable","Promise","resolve","browserSupportsWebAuthnAutofill","document","querySelectorAll","mediation","credential","navigator","credentials","get","err","error","AbortSignal","effectiveDomain","location","rpId","identifyAuthenticationError","rawId","response","type","userHandle","value","TextDecoder","decode","authenticatorData","clientDataJSON","signature","clientExtensionResults","getClientExtensionResults","authenticatorAttachment","_fetch","path","payload","FormData","JSON","stringify","res","fetch","method","headers","body","status","json","result","KTSigninGeneral","form","submitButton","validator","signInWithPasskeyButton","signInWithUsernameAndPasswordLink","signInWithPasskeyContainer","signInWithUsernameAndPasswordContainer","lang","localStorage","getItem","getElementsByTagName","getAttribute","texts","translate","text","webauthnSignin","username","requireUserVerification","asseResp","authenticate","href","querySelector","e","click","Swal","fire","icon","buttonsStyling","confirmButtonText","customClass","confirmButton","init","typingTimer","doneTypingInterval","usernameInput","usernameEvent","clearTimeout","setTimeout","doneTyping","addEventListener","preventDefault","removeEventListener","classList","add","remove","FormValidation","formValidation","fields","validators","regexp","notEmpty","plugins","trigger","Trigger","bootstrap","Bootstrap5","rowSelector","eleInvalidClass","eleValidClass","url","URL","isValidUrl","closest","validate","then","setAttribute","disabled","formData","loginInfo","forEach","key","axios","post","CMSRouting","generate","axiosConfig","removeAttribute","redirect","data","timer","showConfirmButton","host","protocol","catch","handleSubmitAjax"],"sourceRoot":""}