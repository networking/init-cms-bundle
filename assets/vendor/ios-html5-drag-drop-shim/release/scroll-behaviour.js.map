{"version":3,"file":null,"sources":["/Users/stefansteinhart/Development/Web/ios-html5-drag-drop-shim/src/scroll-behaviour.ts"],"sourcesContent":["//<editor-fold desc=\"static scroll utils\">\n\nimport {DragImageTranslateOverrideFn, Point} from \"./index\";\n\ninterface ScrollIntentions {\n    horizontal: ScrollIntention;\n    vertical: ScrollIntention;\n}\n\ninterface IScrollBounds {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    scrollX: number;\n    scrollY: number;\n    scrollHeight: number;\n    scrollWidth: number;\n}\n\nconst enum ScrollIntention {\n    NONE = 0,\n    LEFT_OR_TOP = -1,\n    RIGHT_OR_BOTTOM = 1\n}\n\nconst enum ScrollAxis {\n    HORIZONTAL,\n    VERTICAL\n}\n\nfunction isTopLevelEl(el: HTMLElement): boolean {\n\n    return (el === document.body || el === document.documentElement);\n}\n\nfunction getElementViewportOffset(el: HTMLElement, axis: ScrollAxis) {\n    let offset: number;\n\n    if (isTopLevelEl(el)) {\n        offset = (axis === ScrollAxis.HORIZONTAL) ? el.clientLeft : el.clientTop;\n    }\n    else {\n        const bounds = el.getBoundingClientRect();\n        offset = (axis === ScrollAxis.HORIZONTAL) ? bounds.left : bounds.top;\n    }\n\n    return offset;\n}\n\nfunction getElementViewportSize(el: HTMLElement, axis: ScrollAxis) {\n    let size: number;\n\n    if (isTopLevelEl(el)) {\n        size = (axis === ScrollAxis.HORIZONTAL) ? window.innerWidth : window.innerHeight;\n    }\n    else {\n        size = (axis === ScrollAxis.HORIZONTAL) ? el.clientWidth : el.clientHeight;\n    }\n\n    return size;\n}\n\nfunction getSetElementScroll(el: HTMLElement, axis: ScrollAxis, scroll?: number) {\n    const prop = (axis === ScrollAxis.HORIZONTAL) ? \"scrollLeft\" : \"scrollTop\";\n\n    // abstracting away compatibility issues on scroll properties of document/body\n    const isTopLevel = isTopLevelEl(el);\n\n    if (arguments.length === 2) {\n\n        if (isTopLevel) {\n            return document.body[prop] || document.documentElement[prop];\n        }\n\n        return el[prop];\n    }\n\n    if (isTopLevel) {\n        document.documentElement[prop] += scroll;\n        document.body[prop] += scroll;\n    }\n    else {\n        el[prop] += scroll;\n    }\n}\n\n//TODO check if scroll end is reached according to scroll intention? this is needed to implement scroll chaining\nfunction isScrollable(el: HTMLElement): boolean {\n    const cs = getComputedStyle(el);\n\n    if (el.scrollHeight > el.clientHeight && (cs.overflowY === \"scroll\" || cs.overflowY === \"auto\")) {\n        return true;\n    }\n\n    if (el.scrollWidth > el.clientWidth && (cs.overflowX === \"scroll\" || cs.overflowX === \"auto\")) {\n        return true;\n    }\n\n    return false;\n}\n\nfunction findScrollableParent(el: HTMLElement): HTMLElement {\n    do {\n        if (!el) {\n            return undefined;\n        }\n        if (isScrollable(el)) {\n            return el;\n        }\n        if (el === document.documentElement) {\n            return null;\n        }\n    } while (el = <HTMLElement>el.parentNode);\n    return null;\n}\n\nfunction determineScrollIntention(currentCoordinate: number, size: number, threshold: number): ScrollIntention {\n\n    // LEFT / TOP\n    if (currentCoordinate < threshold) {\n        return ScrollIntention.LEFT_OR_TOP;\n    }\n    // RIGHT / BOTTOM\n    else if (size - currentCoordinate < threshold) {\n        return ScrollIntention.RIGHT_OR_BOTTOM;\n    }\n    // NONE\n    return ScrollIntention.NONE;\n}\n\nfunction determineDynamicVelocity(scrollIntention: ScrollIntention, currentCoordinate: number, size: number, threshold: number): number {\n\n    if (scrollIntention === ScrollIntention.LEFT_OR_TOP) {\n\n        return Math.abs(currentCoordinate - threshold);\n    }\n    else if (scrollIntention === ScrollIntention.RIGHT_OR_BOTTOM) {\n\n        return Math.abs(size - currentCoordinate - threshold);\n    }\n\n    return 0;\n}\n\nfunction isScrollEndReached(axis: ScrollAxis, scrollIntention: ScrollIntention, scrollBounds: IScrollBounds) {\n\n    const currentScrollOffset = (axis === ScrollAxis.HORIZONTAL) ? (scrollBounds.scrollX) : (scrollBounds.scrollY);\n\n    // wants to scroll to the right/bottom\n    if (scrollIntention === ScrollIntention.RIGHT_OR_BOTTOM) {\n\n        const maxScrollOffset = (axis === ScrollAxis.HORIZONTAL) ? ( scrollBounds.scrollWidth - scrollBounds.width ) : ( scrollBounds.scrollHeight -\n            scrollBounds.height );\n\n        // is already at the right/bottom edge\n        return currentScrollOffset >= maxScrollOffset;\n    }\n    // wants to scroll to the left/top\n    else if (scrollIntention === ScrollIntention.LEFT_OR_TOP) {\n\n        // is already at left/top edge\n        return (currentScrollOffset <= 0);\n    }\n    // no scroll\n    return true;\n}\n\n//</editor-fold>\n\nlet _options: ScrollOptions = {\n    threshold: 75,\n    // simplified cubic-ease-in function\n    velocityFn: function (velocity: number, threshold: number) {\n        const multiplier = velocity / threshold;\n        const easeInCubic = multiplier * multiplier * multiplier;\n        return easeInCubic * threshold;\n    }\n};\n\nlet _scrollIntentions: ScrollIntentions = {\n    horizontal: ScrollIntention.NONE,\n    vertical: ScrollIntention.NONE\n};\n\nlet _dynamicVelocity: Point = {\n    x: 0,\n    y: 0\n};\n\nlet _scrollAnimationFrameId: any;\nlet _currentCoordinates: Point;\nlet _hoveredElement: HTMLElement;\nlet _scrollableParent: HTMLElement;\nlet _translateDragImageFn: (offsetX: number, offsetY: number) => void;\n\n/**\n * core handler function\n */\nfunction handleDragImageTranslateOverride(event: TouchEvent,\n                                          currentCoordinates: Point,\n                                          hoveredElement: HTMLElement,\n                                          translateDragImageFn: (scrollDiffX: number, scrollDiffY: number) => void): void {\n\n    _currentCoordinates = currentCoordinates;\n    _translateDragImageFn = translateDragImageFn;\n\n    // update parent if hovered element changed\n    if (_hoveredElement !== hoveredElement) {\n\n        _hoveredElement = hoveredElement;\n        _scrollableParent = findScrollableParent(_hoveredElement);\n    }\n\n    // update scroll intention and check if we should scroll at all\n    //TODO implement scroll chaining? if scroll end is reached continue to look for scrollable parent\n    const performScrollAnimation = updateScrollIntentions(_currentCoordinates, _scrollableParent, _options.threshold, _scrollIntentions, _dynamicVelocity);\n\n    // no animation in progress but scroll is intended\n    if (performScrollAnimation) {\n\n        // setup scroll animation frame\n        scheduleScrollAnimation();\n    }\n    else if (!!_scrollAnimationFrameId) {\n\n        window.cancelAnimationFrame(_scrollAnimationFrameId);\n        _scrollAnimationFrameId = null;\n    }\n}\n\n//<editor-fold desc=\"programmatic scroll animation frame handler\">\n\nfunction scheduleScrollAnimation() {\n\n    // prevent scheduling when already scheduled\n    if (!!_scrollAnimationFrameId) {\n\n        return;\n    }\n\n    _scrollAnimationFrameId = window.requestAnimationFrame(scrollAnimation);\n}\n\nfunction scrollAnimation() {\n\n    let scrollDiffX = 0,\n        scrollDiffY = 0,\n        isTopLevel = isTopLevelEl(_scrollableParent);\n\n    if (_scrollIntentions.horizontal !== ScrollIntention.NONE) {\n\n        scrollDiffX = Math.round(_options.velocityFn(_dynamicVelocity.x, _options.threshold) * _scrollIntentions.horizontal);\n        getSetElementScroll(_scrollableParent, ScrollAxis.HORIZONTAL, scrollDiffX);\n    }\n\n    if (_scrollIntentions.vertical !== ScrollIntention.NONE) {\n\n        scrollDiffY = Math.round(_options.velocityFn(_dynamicVelocity.y, _options.threshold) * _scrollIntentions.vertical);\n        getSetElementScroll(_scrollableParent, ScrollAxis.VERTICAL, scrollDiffY);\n    }\n\n    if (isTopLevel) {\n        // on top level element scrolling we need to translate the drag image as much as we scroll\n        _translateDragImageFn(scrollDiffX, scrollDiffY);\n    }\n    else {\n        // just scroll the container and update the drag image position without offset\n        _translateDragImageFn(0, 0);\n    }\n\n    // reset to make sure we can re-schedule scroll animation\n    _scrollAnimationFrameId = null;\n\n    // check if we should continue scrolling\n    //TODO implement scroll chaining? if scroll end is reached continue to look for scrollable parent\n    if (updateScrollIntentions(_currentCoordinates, _scrollableParent, _options.threshold, _scrollIntentions, _dynamicVelocity)) {\n\n        // re-schedule animation frame callback\n        scheduleScrollAnimation();\n    }\n}\n\n//</editor-fold>\n\n//<editor-fold desc=\"scroll checks\">\n\nfunction updateScrollIntentions(currentCoordinates: Point,\n                                scrollableParent: HTMLElement,\n                                threshold: number,\n                                scrollIntentions: ScrollIntentions,\n                                dynamicVelocity: Point): boolean {\n\n    if (!currentCoordinates || !scrollableParent) {\n\n        // when coordinates become undefined drag operation stopped. stop scrolling also.\n        return false;\n    }\n\n    const scrollableParentBounds: IScrollBounds = {\n        x: getElementViewportOffset(scrollableParent, ScrollAxis.HORIZONTAL),\n        y: getElementViewportOffset(scrollableParent, ScrollAxis.VERTICAL),\n        width: getElementViewportSize(scrollableParent, ScrollAxis.HORIZONTAL),\n        height: getElementViewportSize(scrollableParent, ScrollAxis.VERTICAL),\n        scrollX: getSetElementScroll(scrollableParent, ScrollAxis.HORIZONTAL),\n        scrollY: getSetElementScroll(scrollableParent, ScrollAxis.VERTICAL),\n        scrollWidth: scrollableParent.scrollWidth,\n        scrollHeight: scrollableParent.scrollHeight\n    };\n\n    const currentCoordinatesOffset = {\n        x: currentCoordinates.x - scrollableParentBounds.x,\n        y: currentCoordinates.y - scrollableParentBounds.y\n    };\n\n    scrollIntentions.horizontal = determineScrollIntention(currentCoordinatesOffset.x, scrollableParentBounds.width, threshold);\n    scrollIntentions.vertical = determineScrollIntention(currentCoordinatesOffset.y, scrollableParentBounds.height, threshold);\n\n    if (scrollIntentions.horizontal && isScrollEndReached(ScrollAxis.HORIZONTAL, scrollIntentions.horizontal, scrollableParentBounds)) {\n\n        // if scroll end is reached, reset to none\n        scrollIntentions.horizontal = ScrollIntention.NONE;\n    }\n    else if (scrollIntentions.horizontal) {\n\n        dynamicVelocity.x = determineDynamicVelocity(scrollIntentions.horizontal, currentCoordinatesOffset.x, scrollableParentBounds.width, threshold);\n    }\n\n    if (scrollIntentions.vertical && isScrollEndReached(ScrollAxis.VERTICAL, scrollIntentions.vertical, scrollableParentBounds)) {\n\n        // if scroll end is reached, reset to none\n        scrollIntentions.vertical = ScrollIntention.NONE;\n    }\n    else if (scrollIntentions.vertical) {\n\n        dynamicVelocity.y = determineDynamicVelocity(scrollIntentions.vertical, currentCoordinatesOffset.y, scrollableParentBounds.height, threshold);\n    }\n\n    return !!(scrollIntentions.horizontal || scrollIntentions.vertical);\n}\n\n//</editor-fold>\n\n//<editor-fold desc=\"public api\">\n\nexport interface ScrollOptions {\n    // threshold in px. when distance between scrollable element edge and touch position is smaller start programmatic scroll.\n    // defaults to 75px\n    threshold?: number;\n    // function to customize the scroll velocity\n    // velocity param: distance to scrollable element edge\n    // threshold: the threshold used to determine when scrolling should start\n    // defaults to cubic-ease-in.\n    velocityFn: (velocity: number, threshold: number) => number;\n}\n\nexport const scrollBehaviourDragImageTranslateOverride: DragImageTranslateOverrideFn = handleDragImageTranslateOverride;\n\n//</editor-fold>\n"],"names":[],"mappings":"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"}